================================================================================
                    OOP 4 PILLARS IN HOSPITAL MANAGEMENT SYSTEM
                    Summary Document with Code Examples
================================================================================

================================================================================
1. ENCAPSULATION ✅
================================================================================

HOW IT'S IMPLEMENTED:
Encapsulation is implemented using private fields with public getter/setter 
methods to control access to data, ensuring data security and protection.

CODE EXAMPLE FROM PROJECT:

File: src/pack1/Patient.java

public class Patient extends Person {
    // PRIVATE FIELDS - Data is hidden (encapsulated)
    private String password;
    private String bloodGroup;
    private double medBill = 0;
    
    // PUBLIC METHODS - Controlled access
    public double getMedBill() { 
        return medBill; 
    }
    
    public void addBill(double amount) { 
        this.medBill += amount; 
    }
    
    // Password cannot be accessed directly - security!
    public boolean checkPass(String p) { 
        return this.password.equals(p); 
    }
}

USAGE:
Patient p = new Patient("John", "pass123", "9876543210", 35, "O+");
p.addBill(50.00);              // ✅ Can modify through public method
// p.medBill = 100;            // ❌ ERROR: medBill is private
double bill = p.getMedBill();  // ✅ Can read through public method

================================================================================
2. INHERITANCE ✅
================================================================================

HOW IT'S IMPLEMENTED:
Inheritance is implemented using the 'extends' keyword. Patient class extends 
Person class, inheriting name, mobile, and age fields with getter methods.

CODE EXAMPLE FROM PROJECT:

File: src/pack1/Person.java (Parent Class)

public class Person {
    protected String name;
    protected String mobile;
    protected int age;
    
    public Person(String name, String mobile, int age) {
        this.name = name;
        this.mobile = mobile;
        this.age = age;
    }
    
    public String getName() { return name; }
    public String getMobile() { return mobile; }
    public int getAge() { return age; }
}

File: src/pack1/Patient.java (Child Class)

public class Patient extends Person {
    private String password;
    private String bloodGroup;
    
    public Patient(String name, String password, String mobile, int age, String bloodGroup) {
        super(name, mobile, age);  // Calls Person constructor
        this.password = password;
        this.bloodGroup = bloodGroup;
    }
    
    public String getUsername() { return name; }  // Uses inherited 'name' field
}

USAGE:
Patient p = new Patient("John", "pass123", "9876543210", 35, "O+");
System.out.println(p.getName());   // ✅ Inherited from Person
System.out.println(p.getMobile()); // ✅ Inherited from Person
System.out.println(p.getAge());    // ✅ Inherited from Person

================================================================================
3. POLYMORPHISM ✅
================================================================================

HOW IT'S IMPLEMENTED:
Polymorphism is implemented through method overloading - same method name with 
different parameters, allowing flexibility in method calls.

CODE EXAMPLE FROM PROJECT:

File: src/pack2/HospitalAdmin.java

public class HospitalAdmin {
    
    // Method Overloading - Same method name, different parameters
    
    // Version 1: Validate mobile as String
    public boolean isValidMobile(String mobile) {
        if (mobile == null || mobile.length() != 10) return false;
        for (int i = 0; i < mobile.length(); i++) {
            if (mobile.charAt(i) < '0' || mobile.charAt(i) > '9') return false; 
        }
        char f = mobile.charAt(0);
        return (f == '9' || f == '8' || f == '7' || f == '6');
    }
    
    // Search by specialty
    public void searchDoctorBySpecialty(String spec) {
        System.out.println("Results for " + spec + ":");
        boolean found = false;
        System.out.printf("%-5s %-20s %-20s%n", "ID", "Name", "Specialty");
        for(int i = 0; i < doctorCount; i++) {
            if(doctors[i].specialty.toLowerCase().contains(spec.toLowerCase())) {
                System.out.printf("%-5d %-20s %-20s%n", 
                    doctors[i].id, doctors[i].name, doctors[i].specialty);
                found = true;
            }
        }
        if(!found) System.out.println("No doctors found.");
    }
}

USAGE:
HospitalAdmin admin = new HospitalAdmin();
boolean valid = admin.isValidMobile("9876543210");        // String parameter
admin.searchDoctorBySpecialty("Cardiology");              // One parameter

================================================================================
4. ABSTRACTION ✅
================================================================================

HOW IT'S IMPLEMENTED:
Abstraction is implemented by hiding complex internal implementation (arrays, 
loops, validation) behind simple public methods, providing easy-to-use interfaces.

CODE EXAMPLE FROM PROJECT:

File: src/pack2/HospitalAdmin.java

public class HospitalAdmin {
    // PRIVATE - Complex implementation hidden from user
    private Patient[] patients = new Patient[100]; 
    private int patientCount = 0; 

    // PUBLIC - Simple interface for user
    public String register(String name, String pass, String mobile, int age, String bg) {
        // Complex internal logic is hidden:
        // - Array management
        // - Validation checks
        // - Error handling
        if(patientCount >= patients.length) return "Error: Database Full.";
        if(!isValidName(name)) return "Error: Name must contain only letters and spaces.";
        if(!isValidPassword(pass)) return "Error: Password too short.";
        if(!isValidMobile(mobile)) return "Error: Invalid Mobile.";
        if(!isValidBloodGroup(bg)) return "Error: Invalid Blood Group.";
        if(isUserExists(name)) return "Error: Username exists.";

        patients[patientCount++] = new Patient(name, pass, mobile, age, bg);
        return "Success";
    }
    
    public Patient login(String name, String pass, String mobile) {
        // User doesn't see: array operations, search loops, internal logic
        for(int i = 0; i < patientCount; i++) {
            Patient p = patients[i];
            if(p.getUsername().equals(name) && 
               p.checkPass(pass) && 
               p.getMobile().equals(mobile)) {
                return p;
            }
        }
        return null;
    }
}

USAGE:
HospitalAdmin hospital = new HospitalAdmin();

// USER CODE - Simple and clean (abstraction)
String result = hospital.register("John", "pass123", "9876543210", 35, "O+");
Patient p = hospital.login("John", "pass123", "9876543210");

// User doesn't need to know:
// - How data is stored (arrays)
// - How validation works
// - How search is performed
// - Internal data structures

================================================================================
SUMMARY TABLE
================================================================================

| Pillar         | Status | Implementation                      | Location           |
|----------------|--------|-------------------------------------|-------------------|
| Encapsulation  | ✅     | Private fields + Public methods     | Patient.java      |
| Inheritance    | ✅     | Person → Patient (extends)          | Person.java,      |
|                |        |                                     | Patient.java      |
| Polymorphism   | ✅     | Method Overloading                  | HospitalAdmin.java|
| Abstraction    | ✅     | Hidden implementation details       | HospitalAdmin.java|

================================================================================
CONCLUSION
================================================================================

All 4 OOP pillars are successfully implemented in the Hospital Management System:

✅ Encapsulation  - Data protection through private fields
✅ Inheritance    - Person → Patient class hierarchy  
✅ Polymorphism   - Method overloading for flexibility
✅ Abstraction    - Simple interfaces hide complexity

================================================================================
END OF DOCUMENT
================================================================================

