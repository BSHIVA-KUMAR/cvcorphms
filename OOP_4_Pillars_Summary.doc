================================================================================
                    OOP 4 PILLARS IN HOSPITAL MANAGEMENT SYSTEM
                    Summary Document with Code Examples
================================================================================

================================================================================
1. ENCAPSULATION ✅
================================================================================

HOW IT'S IMPLEMENTED:
Encapsulation is implemented using private fields with public getter/setter 
methods to control access to data, ensuring data security and protection.

CODE EXAMPLE FROM PROJECT:

File: src/pack1/Patient.java

public class Patient extends Person {
    // PRIVATE FIELDS - Data is hidden (encapsulated)
    private String password;
    private String bloodGroup;
    private double medBill = 0;
    
    // PUBLIC METHODS - Controlled access
    public double getMedBill() { 
        return medBill; 
    }
    
    public void addBill(double amount) { 
        this.medBill += amount; 
    }
    
    // Password cannot be accessed directly - security!
    public boolean checkPass(String p) { 
        return this.password.equals(p); 
    }
}

USAGE:
Patient p = new Patient("John", "pass123", "9876543210", 35, "O+");
p.addBill(50.00);              // ✅ Can modify through public method
// p.medBill = 100;            // ❌ ERROR: medBill is private
double bill = p.getMedBill();  // ✅ Can read through public method

================================================================================
2. INHERITANCE ✅
================================================================================

HOW IT'S IMPLEMENTED:
Inheritance is implemented using the 'extends' keyword. Patient class extends 
abstract Person class, inheriting name, mobile, and age fields. Patient implements 
abstract method displayInfo() and overrides toString() using @Override annotation.

CODE EXAMPLE FROM PROJECT:

File: src/pack1/Person.java (Parent Class - ABSTRACT CLASS)

// ABSTRACT CLASS - Cannot be instantiated directly
public abstract class Person {
    protected String name;
    protected String mobile;
    protected int age;
    
    public Person(String name, String mobile, int age) {
        this.name = name;
        this.mobile = mobile;
        this.age = age;
    }
    
    public String getName() { return name; }
    public String getMobile() { return mobile; }
    public int getAge() { return age; }
    
    // ABSTRACT METHOD - Must be implemented by child classes
    public abstract String displayInfo();
}

File: src/pack1/Patient.java (Child Class)

public class Patient extends Person {
    private String password;
    private String bloodGroup;
    
    public Patient(String name, String password, String mobile, int age, String bloodGroup) {
        super(name, mobile, age);  // Calls Person constructor
        this.password = password;
        this.bloodGroup = bloodGroup;
    }
    
    public String getUsername() { return name; }  // Uses inherited 'name' field
    
    // METHOD OVERRIDING with @Override annotation
    // Override abstract method from Person class
    @Override
    public String displayInfo() {
        return "Patient: " + name + " | Mobile: " + mobile + " | Age: " + age + " | Blood Group: " + bloodGroup;
    }
    
    // METHOD OVERRIDING - Override toString() from Object class
    @Override
    public String toString() {
        return "Patient{name='" + name + "', mobile='" + mobile + "', age=" + age + ", bloodGroup='" + bloodGroup + "'}";
    }
}

USAGE:
Patient p = new Patient("John", "pass123", "9876543210", 35, "O+");
System.out.println(p.getName());      // ✅ Inherited from Person
System.out.println(p.getMobile());    // ✅ Inherited from Person
System.out.println(p.getAge());       // ✅ Inherited from Person
System.out.println(p.displayInfo());  // ✅ Overridden method from Person (abstract)
System.out.println(p.toString());     // ✅ Overridden method from Object class

================================================================================
3. POLYMORPHISM ✅
================================================================================

HOW IT'S IMPLEMENTED:
Polymorphism is implemented through method overloading - same method name with 
different parameters, allowing flexibility in method calls.

CODE EXAMPLE FROM PROJECT:

File: src/pack2/HospitalAdmin.java

public class HospitalAdmin {
    
    // METHOD OVERLOADING - Same method name, different parameters
    
    // Overload 1: Validate password with default minimum length (6)
    public boolean isValidPassword(String pass) { 
        return pass != null && pass.length() >= 6; 
    }
    
    // Overload 2: Validate password with custom minimum length
    public boolean isValidPassword(String pass, int minLength) {
        return pass != null && pass.length() >= minLength;
    }
    
    // Overload 3: Validate password with special character requirement
    public boolean isValidPassword(String pass, boolean requireSpecialChar) {
        if(pass == null || pass.length() < 6) return false;
        if(!requireSpecialChar) return true;
        for(char c : pass.toCharArray()) {
            if(!Character.isLetterOrDigit(c)) return true;
        }
        return false;
    }
    
    // Overload 1: Search by specialty (case-insensitive by default)
    public void searchDoctorBySpecialty(String spec) {
        System.out.println("Results for " + spec + ":");
        boolean found = false;
        System.out.printf("%-5s %-20s %-20s%n", "ID", "Name", "Specialty");
        for(int i = 0; i < doctorCount; i++) {
            if(doctors[i].specialty.toLowerCase().contains(spec.toLowerCase())) {
                System.out.printf("%-5d %-20s %-20s%n", 
                    doctors[i].id, doctors[i].name, doctors[i].specialty);
                found = true;
            }
        }
        if(!found) System.out.println("No doctors found.");
    }
    
    // Overload 2: Search by specialty with case sensitivity option
    public void searchDoctorBySpecialty(String spec, boolean caseSensitive) {
        System.out.println("Results for " + spec + ":");
        boolean found = false;
        System.out.printf("%-5s %-20s %-20s%n", "ID", "Name", "Specialty");
        for(int i = 0; i < doctorCount; i++) {
            String doctorSpec = caseSensitive ? doctors[i].specialty : doctors[i].specialty.toLowerCase();
            String searchSpec = caseSensitive ? spec : spec.toLowerCase();
            if(doctorSpec.contains(searchSpec)) {
                System.out.printf("%-5d %-20s %-20s%n", 
                    doctors[i].id, doctors[i].name, doctors[i].specialty);
                found = true;
            }
        }
        if(!found) System.out.println("No doctors found.");
    }
}

USAGE:
HospitalAdmin admin = new HospitalAdmin();

// Method Overloading Examples:
// Password validation - 3 different ways
boolean valid1 = admin.isValidPassword("pass123");              // Default (min 6 chars)
boolean valid2 = admin.isValidPassword("pass123", 8);          // Custom length (min 8 chars)
boolean valid3 = admin.isValidPassword("pass123!", true);      // With special char requirement

// Doctor search - 2 different ways
admin.searchDoctorBySpecialty("Cardiology");                   // Case-insensitive (default)
admin.searchDoctorBySpecialty("Cardiology", true);            // Case-sensitive search

================================================================================
4. ABSTRACTION ✅
================================================================================

HOW IT'S IMPLEMENTED:
Abstraction is implemented through Abstract Class (Person) and by hiding complex 
internal implementation (arrays, loops, validation) behind simple public methods, 
providing easy-to-use interfaces.

CODE EXAMPLE FROM PROJECT:

File: src/pack2/HospitalAdmin.java

public class HospitalAdmin {
    // PRIVATE - Complex implementation hidden from user
    private Patient[] patients = new Patient[100]; 
    private int patientCount = 0; 

    // PUBLIC - Simple interface for user
    public String register(String name, String pass, String mobile, int age, String bg) {
        // Complex internal logic is hidden:
        // - Array management
        // - Validation checks
        // - Error handling
        if(patientCount >= patients.length) return "Error: Database Full.";
        if(!isValidName(name)) return "Error: Name must contain only letters and spaces.";
        if(!isValidPassword(pass)) return "Error: Password too short.";
        if(!isValidMobile(mobile)) return "Error: Invalid Mobile.";
        if(!isValidBloodGroup(bg)) return "Error: Invalid Blood Group.";
        if(isUserExists(name)) return "Error: Username exists.";

        patients[patientCount++] = new Patient(name, pass, mobile, age, bg);
        return "Success";
    }
    
    public Patient login(String name, String pass, String mobile) {
        // User doesn't see: array operations, search loops, internal logic
        for(int i = 0; i < patientCount; i++) {
            Patient p = patients[i];
            if(p.getUsername().equals(name) && 
               p.checkPass(pass) && 
               p.getMobile().equals(mobile)) {
                return p;
            }
        }
        return null;
    }
}

USAGE:
HospitalAdmin hospital = new HospitalAdmin();

// USER CODE - Simple and clean (abstraction)
String result = hospital.register("John", "pass123", "9876543210", 35, "O+");
Patient p = hospital.login("John", "pass123", "9876543210");

// User doesn't need to know:
// - How data is stored (arrays)
// - How validation works
// - How search is performed
// - Internal data structures

================================================================================
SUMMARY TABLE
================================================================================

| Pillar         | Status | Implementation                      | Location           |
|----------------|--------|-------------------------------------|-------------------|
| Encapsulation  | ✅     | Private fields + Public methods     | Patient.java      |
| Inheritance    | ✅     | Person (abstract) → Patient (extends)| Person.java,      |
|                |        | Method Overriding with @Override    | Patient.java      |
| Polymorphism   | ✅     | Method Overloading                  | HospitalAdmin.java|
| Abstraction    | ✅     | Abstract Class + Hidden details     | Person.java,      |
|                |        |                                     | HospitalAdmin.java|

ADDITIONAL FEATURES:
- ✅ Abstract Class: Person is abstract with abstract method displayInfo()
- ✅ Method Overriding: Patient overrides displayInfo() and toString() with @Override annotation
- ✅ Method Overloading: Multiple versions of isValidPassword() and searchDoctorBySpecialty()

================================================================================
CONCLUSION
================================================================================

All 4 OOP pillars are successfully implemented in the Hospital Management System:

✅ Encapsulation  - Data protection through private fields
✅ Inheritance    - Person (abstract) → Patient class hierarchy with method overriding
✅ Polymorphism   - Method overloading (isValidPassword, searchDoctorBySpecialty)
✅ Abstraction    - Abstract class (Person) and hidden implementation details

ADVANCED OOP FEATURES:
✅ Abstract Class - Person class with abstract method displayInfo()
✅ Method Overriding - Patient overrides displayInfo() and toString() with @Override annotation
✅ Method Overloading - Multiple versions of isValidPassword() and searchDoctorBySpecialty()
✅ Annotations - @Override annotation for method overriding

================================================================================
END OF DOCUMENT
================================================================================


